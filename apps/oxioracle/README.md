# OXIOracle

A coding challenge submission by [John Coppola](https://www.johnnycopes.com/).

## Links

1. [Live site](https://oxioracle.surge.sh)
1. [GitHub codespaces](https://probable-robot-5grv69jwjx5c4j6.github.dev/)
1. [Commit history](https://github.com/johnnycopes/atocha/pull/554/commits)
1. [All code changes](https://github.com/johnnycopes/atocha/pull/554/files)

## Setup

Via GitHub codespaces:

1. Open the [codespaces project](https://probable-robot-5grv69jwjx5c4j6.github.dev)
1. Run `npm start oxioracle` in the Codespaces terminal
1. Open https://probable-robot-5grv69jwjx5c4j6-4800.app.github.dev to see the application running

Locally on your machine:

1. Run `git clone https://github.com/johnnycopes/atocha.git` to clone the project monorepo
1. Run `npm install` in your terminal to install all dependencies
1. Run `git checkout oxio` to access the feature branch
1. Run `npm start oxioracle` to boot the application
1. Visit http://localhost:4800 in your browser to see the application running

## Technical details

### Tools used:

1. [Nx](https://nx.dev/) (monorepo)
2. [Angular](https://angular.dev/) (front-end framework), which includes HTML, CSS, TypeScript, and RxJS
3. [Jest](https://jestjs.io/) (unit testing)
4. [Cypress](https://www.cypress.io/) (e2e testing)
5. [Angular Material](https://material.angular.io/components/table/overview) (for the table)
6. [ng2-charts](https://valor-software.com/ng2-charts/) (for the charts)

### Project location

I created Oxioracle as a feature branch inside of [Atocha](https://github.com/johnnycopes/atocha/tree/oxio), my personal Nx monorepo where I manage all of my current applications and libraries, rather than creating an independent repository for this project. This allowed me to reuse code that I leverage elsewhere, utilize my existing CI/CD pipeline, and save significant time when installing libraries and writing tests.

### Data

I used the [JSONplaceholder API](https://jsonplaceholder.typicode.com) mentioned in the project instructions to supply the application with data. I called the `/todos` endpoint, which returns a consistent 200 [todos](https://jsonplaceholder.typicode.com/todos). Exactly one API call is made in OXIOracle to fetch the data (while the application is booting, inside the [`APP_INITIALIZER` function](https://github.com/johnnycopes/atocha/blob/8d757a3da145317212fd6f8d76004a02ae269942/apps/oxioracle/src/app/app.config.ts#L33-L37)) and the results are then stored in local state for consumption by the UI.

All state for fetching todo data and managing local todos state happens in the `TodoService`. Internally, that service uses the `ApiService` to fetch the data (with help from Angular's `HttpClient` service) and my own custom [`State` class](https://github.com/johnnycopes/atocha/blob/main/libs/core/data-access/src/lib/state.ts) (a generic RxJS observable store) for state management.

All chart is managed by the `ChartService`. However, nothing about the charts' state is persisted, so its purpose is ultimately to transform the todo data into the correct shape for the charts to consume.

### Sortable table

Creating a data grid (aka table) with meaningful functionality is an onerous undertaking in UI development. Due to the limited scope of this project, I chose to use Google's Angular Material `<mat-table>` for this feature ([docs link](https://material.angular.io/components/table/overview)). The todo data fields are separated by columns, which can each be sorted in ascending or descending order. The current sorting configuration is stored in local state.

### Alternate data visualization

Similar to the table, creating custom charts without help from a library is a project unto itself. I chose to use [ng2-charts](https://valor-software.com/ng2-charts/), which is an Angular wrapper around the framework-agnostic [chart.js](https://www.chartjs.org/). I chose to display two charts: one showing the todos associated with each user ID (all todos, completed todos, and incomplete todos) and another to display the overall state of completed vs. incomplete todos belonging to all users.

### Data entry form

I leaned on Angular's `ReactiveFormsModule` to build the form for adding a new todo. The ID is automatically generated by the application, but the user ID, title, and completion state are defined by the user. There's validation logic on all fields that will throw visible errors if everything isn't filled out on failed submission. There's also a toast message that launches when a new todo is successful submission.

### Routing

The table and charts each live in their own pages. I opted to put the form on its own page as well, since the routing was already established and it allowed for the other features to maximize their space. The application defaults to the `/table` route on load if a specific route isn't defined. There's also an error page that renders if the user attempts to visit an invalid route. All viable pages can be navigated to via the header at the top of the application.

### Testing

All test output can be seen in the [pipeline check](https://github.com/johnnycopes/atocha/actions/runs/10256081924/job/28374429808?pr=554) that runs against the feature branch's PR on every push.

#### Unit tests (Jest)

These can be run locally with `nx run-many -t test`. Examples:

1. The [`State` class](https://github.com/johnnycopes/atocha/blob/main/libs/core/data-access/src/lib/state.spec.ts)
2. The [`Form` class](https://github.com/johnnycopes/atocha/blob/oxio/libs/core/util/src/lib/format.spec.ts)
3. The `groupBy` [logic](https://github.com/johnnycopes/atocha/blob/oxio/libs/oxioracle/feature-data/src/lib/charts/group-by.spec.ts) used by the first chart
4. The `memo` [logic](https://github.com/johnnycopes/atocha/blob/oxio/libs/oxioracle/data-access/src/lib/memo.spec.ts) used for new todo ID generation

#### e2e tests (Cypress)

These can be run locally with `nx e2e oxioracle-e2e`. Example:

1. The [navigation links and routes](https://github.com/johnnycopes/atocha/blob/oxio/apps/oxioracle-e2e/src/e2e/app.cy.ts)

### Performance

Some highlights as to what makes Oxioracle fast:

1. Exactly one API call is made on app initialization. Afterwards, all data is managed locally
2. All Angular components use the `OnPush` change detection strategy to avoid unnecessary re-renders
3. The routing is technically not lazy-loaded, but it'd be easy to do so by splitting the feature components into separate Nx libraries. I didn't see it as necessary in this case because the application is small, but it's standard practice in real-world projects

### Wish list

If I'd had more time, I would have liked to:

1. Improve the uniformity of the UI (make the table and charts look more integrated into the app)
2. Come up with a more sophisticated way to integrate the form into the application. Putting it on its own page is sufficient, but feels a bit clunky
3. Add more capabilities to the table, like searching
4. Load more significant amounts of data into the app
5. Create more charts
